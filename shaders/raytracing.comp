#version 450

layout(local_size_x = 16, local_size_y = 16) in;
layout(set = 0, binding = 0, rgba8) uniform writeonly image2D img;

struct Camera {
  vec3 position;
  vec3 view;
  vec3 right;
  vec3 up;
};

layout (set = 0, binding = 1) uniform Constants
{
  Camera camera;
};

layout(set = 0, binding = 2) buffer Statistics
{
  uint triangle_tests;
  uint triangle_intersections;
};

layout (std140, set = 1, binding = 0) buffer Positions
{
  vec3 positions[];
};

layout (std140, set = 1, binding = 1) buffer Indices
{
  uvec3 indices[];
};

layout (std140, set = 1, binding = 2) buffer Noramls
{
  vec3 normals[];
};

layout (std140, set = 1, binding = 3) buffer TexCoords
{
  vec2 texcoords[];
};

struct Model {
  uint indices_start;
  uint indices_end;
  int material_idx;
};

layout (std140, set = 1, binding = 4) buffer Models
{
  Model models[];
};

struct Material {
  vec3 ambient;
  vec3 diffuse;
  vec3 specular;
  float shininess;
  float dissolve;
  float optical_density;
  int ambient_texture_idx;
  int diffuse_texture_idx;
  int specular_texture_idx;
  int normal_texture_idx;
  int disolve_texture_idx;
};

layout (std140, set = 1, binding = 5) buffer Materials
{
  Material materials[];
};

// I would like to use sampler2DArray, but this extension is supported only by NVidia
// Maximum number of 16, however, is supported by 97% of GPUs
layout(set = 1, binding = 6) uniform sampler2D diffuse_textures[16];

struct Ray {
  vec3 orig;
  vec3 dir;
};

struct IntersectionResult {
  vec2 uv;
  float time;
  uvec3 triangle;
  bool intersect;
};

IntersectionResult intersection(in vec2 uv, in float time, in uvec3 triangle) {
  IntersectionResult result;
  result.uv = uv;
  result.time = time;
  result.triangle = triangle;
  result.intersect = true;
  return result;
}

IntersectionResult void_intersection() {
  IntersectionResult result;
  result.time = 1e20;
  result.uv = vec2(0.0);
  result.intersect = false;
  return result;
}

IntersectionResult no_intersection() {
  IntersectionResult result;
  result.intersect = false;
  return result;
}

IntersectionResult intersect(in Ray ray, in uvec3 triangle)
{
  atomicAdd(triangle_tests, 1);

  const float kEpsilon = 1e-8;
  vec3 v0 = positions[triangle.x];
  vec3 v1 = positions[triangle.y];
  vec3 v2 = positions[triangle.z];
  vec3 v0v1 = v1 - v0;
  vec3 v0v2 = v2 - v0;
  vec3 pvec = cross(ray.dir, v0v2);
  float det = dot(v0v1, pvec);
  if (abs(det) < kEpsilon) {
    return no_intersection();
  }
  float invDet = 1.0 / det;

  vec3 tvec = ray.orig - v0;
  float u = dot(tvec, pvec) * invDet;
  if (u < 0.0 || u > 1.0) {
    return no_intersection();
  }

  vec3 qvec = cross(tvec, v0v1);
  float v = dot(ray.dir, qvec) * invDet;
  if (v < 0.0 || u + v > 1.0) {
    return no_intersection();
  }

  float t = dot(v0v2, qvec) * invDet;
  if (t < 0) {
    return no_intersection();
  }

  atomicAdd(triangle_intersections, 1);
  return intersection(vec2(u, v), t, triangle);
}

IntersectionResult intersect_model(in Ray ray, in Model model) {
  IntersectionResult best = void_intersection();
  for (uint i = model.indices_start; i < model.indices_end; ++i) {
    IntersectionResult result = intersect(ray, indices[i]);
    if (result.intersect && best.time > result.time) {
      best = result;
    }
  }
  return best;
}

vec2 point_st(in uvec3 triangle, in vec3 wuv) {
  vec2 st0 = texcoords[triangle.x];
  vec2 st1 = texcoords[triangle.y];
  vec2 st2 = texcoords[triangle.z];
  return wuv.x * st0 + wuv.y * st1 + wuv.z * st2;
}

vec3 point_norm(in uvec3 triangle, in vec3 wuv) {
  vec3 norm0 = normals[triangle.x];
  vec3 norm1 = normals[triangle.y];
  vec3 norm2 = normals[triangle.z];
  return wuv.x * norm0 + wuv.y * norm1 + wuv.z * norm2;
}

vec3 trace(in Ray ray) {
  IntersectionResult best = void_intersection();
  uint hit_model_idx;
  for (uint i = 0; i < models.length(); ++i) {
    IntersectionResult result = intersect_model(ray, models[i]);
    if (result.intersect && best.time > result.time) {
      best = result;
      hit_model_idx = i;
    }
  }

  if (best.intersect) {
    vec3 wuv = vec3(1.0 - best.uv.x - best.uv.y, best.uv.x, best.uv.y);
    vec3 norm = point_norm(best.triangle, wuv);
    float cosine_factor = dot(norm, ray.dir);
    if (cosine_factor < 0) {
        cosine_factor *= -1.0;
    }
    uint material_idx = models[hit_model_idx].material_idx;
    if (material_idx == -1) {
      return cosine_factor * vec3(1.0, 1.0, 1.0);
    }
    Material material = materials[material_idx];
    if (material.diffuse_texture_idx != -1) {
      vec2 st = point_st(best.triangle, wuv);
      return cosine_factor * texture(diffuse_textures[material.diffuse_texture_idx], st).rgb;
    } else {
      return cosine_factor * vec3(material.diffuse);
    }
  }

  return vec3(0.0, 0.0, 0.0);
}

Ray primary_ray(in vec2 uv, in float aspect_ratio) {
  vec3 dir = camera.view
             + camera.right * (2.0 * uv.x - 1.0)
             + camera.up  * (2.0 * uv.y - 1.0);
  dir.x *= aspect_ratio;
  dir.z *= aspect_ratio;

  Ray ray;
  ray.orig = camera.position;
  ray.dir = normalize(dir);

  return ray;
}

void main() {
  vec2 dim = imageSize(img);
  vec2 uv = vec2(gl_GlobalInvocationID.xy) / dim;
  float aspect_ratio = dim.x / dim.y;
  Ray ray = primary_ray(uv, aspect_ratio);
  vec3 color = trace(ray);
  imageStore(img, ivec2(gl_GlobalInvocationID.xy), vec4(color, 1.0));
}
